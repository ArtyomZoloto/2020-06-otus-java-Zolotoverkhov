Выводы о разных GC:


##### Serial:
При старте приложения шли минорные сборки, по мере заполнения памяти были постоянно полные сборки.
Вывод: На пороге заполнения памяти приложение практически всегда в StopTheWorld и "висит".
Загрузка CPU при свободной памяти 1-2% на minor-сборках. 10-12% на full-сборках.

##### Parallel:
По сравнению с Serial потребляет больше CPU, до 30%.
Судя по графику приложение не так долго как в случае с Serial находилось с забитым
heap, а значит могло отвечать на команды пользователя дольше.

##### CMS:
Сборки происходили очень часто, задействовав ~15% CPU.

##### G1:
По поведению похож на CMS, за исключением того что сборки стартуют
на равном по времени промежуте. Потребляет около 10% CPU. Чем больше
объектов, тем больше CPU потребляется как и у других GC.


Serial: Young-cборок: 10, Full: 46, продолжительность Young 170мс, Full: 550мс
Parallel: Young-cборок: 8, Full: 92, продолжительность Young 140мс, Full: 500мс
CMS: Young-cборок: 18, Full: 30, продолжительность Young 240мс, Full: 750мс
G1 Young-cборок: 54, Full: 24, продолжительность Young 40мс, Full: 370мс

Вывод: Для слабых систем подойдет Serial CG. Для мощных -  у G1 самые короткие паузы, а значит меньше задержка.
Больше всего сборок запускает Parallel, а значит для систем приблеженных к реальному времени будет не пригоден.
У CMS самое долгое время паузы, но full-сборок меньше чем у Serial & Parallel.